package com.mongodb.jdbc;

import com.mongodb.DBCursor;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

public class MongoStatement implements Statement
{
    MongoConnection _conn;
    final int _type;
    final int _concurrency;
    final int _holdability;
    /* 232 */int _fetchSize = 0;
    /* 233 */int _maxRows = 0;
    MongoResultSet _last;

    MongoStatement(MongoConnection conn, int type, int concurrency, int holdability)
    {
        /* 29 */this._conn = conn;
        /* 30 */this._type = type;
        /* 31 */this._concurrency = concurrency;
        /* 32 */this._holdability = holdability;

        /* 34 */if (this._type != 0)
            /* 35 */throw new UnsupportedOperationException("type not supported yet");
        /* 36 */if (this._concurrency != 0)
            /* 37 */throw new UnsupportedOperationException("concurrency not supported yet");
        /* 38 */if (this._holdability != 0)
            /* 39 */throw new UnsupportedOperationException("holdability not supported yet");
    }

    public void addBatch(String sql)
    {
        /* 46 */throw new UnsupportedOperationException("batch not supported");
    }

    public void clearBatch()
    {
        /* 49 */throw new UnsupportedOperationException("batch not supported");
    }

    public int[] executeBatch()
    {
        /* 52 */throw new UnsupportedOperationException("batch not supported");
    }

    public void cancel()
    {
        /* 58 */throw new RuntimeException("not supported yet - can be");
    }

    public void close()
    {
        /* 62 */this._conn = null;
    }

    public Connection getConnection()
    {
        /* 66 */return this._conn;
    }

    public boolean isClosed()
    {
        /* 70 */return this._conn == null;
    }

    public boolean isPoolable()
    {
        /* 74 */return true;
    }

    public void setPoolable(boolean poolable)
    {
        /* 78 */if (!poolable)
            /* 79 */throw new RuntimeException("why don't you want me to be poolable?");
    }

    public void clearWarnings()
    {
        /* 83 */throw new RuntimeException("not supported yet - can be");
    }

    public boolean execute(String sql)
    {
        /* 89 */throw new RuntimeException("execute not done");
    }

    public boolean execute(String sql, int autoGeneratedKeys)
    {
        throw new RuntimeException("execute not done");
    }

    public boolean execute(String sql, int[] columnIndexes)
    {
        throw new RuntimeException("execute not done");
    }

    public boolean execute(String sql, String[] columnNames)
    {
        throw new RuntimeException("execute not done");
    }

    public int executeUpdate(String sql) throws SQLException
    {
        return new Executor(this._conn._db, sql).writeop();
    }

    public int executeUpdate(String sql, int autoGeneratedKeys)
    {
        throw new RuntimeException("executeUpdate not done");
    }

    public int executeUpdate(String sql, int[] columnIndexes)
    {
        throw new RuntimeException("executeUpdate not done");
    }

    public int executeUpdate(String sql, String[] columnNames)
    {
        throw new RuntimeException("executeUpdate not done");
    }

    public int getUpdateCount()
    {
        throw new RuntimeException("getUpdateCount not done");
    }

    public ResultSet getGeneratedKeys()
    {
        throw new RuntimeException("getGeneratedKeys notn done");
    }

    public ResultSet executeQuery(String sql) throws SQLException
    {
        DBCursor cursor = new Executor(this._conn._db, sql).query();
        if (this._fetchSize > 0)
            cursor.batchSize(this._fetchSize);
        if (this._maxRows > 0)
        {
            cursor.limit(this._maxRows);
        }
        this._last = new MongoResultSet(cursor);
        return this._last;
    }

    public int getQueryTimeout()
    {
        throw new RuntimeException("query timeout not done");
    }

    public void setQueryTimeout(int seconds)
    {
        throw new RuntimeException("query timeout not done");
    }

    public int getFetchSize()
    {
        return this._fetchSize;
    }

    public void setFetchSize(int rows)
    {
        this._fetchSize = rows;
    }

    public int getMaxRows()
    {
        return this._maxRows;
    }

    public void setMaxRows(int max)
    {
        this._maxRows = max;
    }

    public int getFetchDirection()
    {
        throw new RuntimeException("fetch direction not done yet");
    }

    public void setFetchDirection(int direction)
    {
        throw new RuntimeException("fetch direction not done yet");
    }

    public int getMaxFieldSize()
    {
        throw new RuntimeException("max field size not supported");
    }

    public void setMaxFieldSize(int max)
    {
        throw new RuntimeException("max field size not supported");
    }

    public boolean getMoreResults()
    {
        throw new RuntimeException("getMoreResults not supported");
    }

    public boolean getMoreResults(int current)
    {
        throw new RuntimeException("getMoreResults not supported");
    }

    public ResultSet getResultSet()
    {
        return this._last;
    }

    public SQLWarning getWarnings()
    {
        throw new UnsupportedOperationException("warning not supported yet");
    }

    public void setCursorName(String name)
    {
        throw new UnsupportedOperationException("can't set cursor name");
    }

    public void setEscapeProcessing(boolean enable)
    {
        if (!enable)
            throw new RuntimeException("why do you want to turn escape processing off?");
    }

    public int getResultSetConcurrency()
    {
        return this._concurrency;
    }

    public int getResultSetHoldability()
    {
        return this._holdability;
    }

    public int getResultSetType()
    {
        return this._type;
    }

    public <T> T unwrap(Class<T> iface) throws SQLException
    {
        throw new UnsupportedOperationException();
    }

    public boolean isWrapperFor(Class<?> iface) throws SQLException
    {
        throw new UnsupportedOperationException();
    }
}
